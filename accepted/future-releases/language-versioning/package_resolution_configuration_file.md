# Package Resolution Configuration File

Author: lrn@google.com
Version: 2.0 (Includes language versioning feature)

This document specifies the location, format and meaning of the  `.packages` file which Dart tools use to resolve `package:` URIs to file locations, and which may include extra metadata as well. It updates the Dart Extension Process [specification document], which originally introduced the `.packages` file, to Dart 2 (no support for packages directories) and language versioning (metadata support).

## The Package Resolution Configuration File.

Dart tools resolve `package:` URIs based on location information found in a `.packages` file, also know as the *package resolution configuration file*.

The package resolution configuration file is a simple text file which associates a base directory (URI) to each available package name. This allows the package files to be accessed from different places. Prior approaches used file-system based symbolic links, which caused a number of issues.
Text files work flawlessly with version control systems and they can be edited with a simple text editor if needed.

### Example

An example `.packages` file generated by the Pub tool could be:

```
# This file has been generate by the Dart tool pub on Oct 14 09:14:14 2019.
# It contains a map from Dart package names to Dart package locations.
# Dart tools, including Dart VM and and Dart analyzer, rely on the content.
# AUTO GENERATED - DO NOT EDIT
:current
test:/home/somebody/.pub/cache/test-1.6.0/lib/#dart=2.4
async:/home/somebody/.pub/cache/async-1.1.0/lib/#dart=2.3
quiver:/home/somebody/.pub/cache/quiver-1.2.1/lib/#dart=2.4
current:lib/#dart=2.5
```

This package configuration will allow a program to import `package:test/test.dart` and receive the file `/home/somebody/.pub/cache/test-1.6.0/lib/test.dart`.

### Syntax

The package resolution configuration file contains a list of package name/package location pairs, separated by a `:` character, and optionally a single default package declaration on a line starting with `:`. The syntax is:

- The file must be valid UTF-8 text (no overlong encodings). It can only contain non-ASCII characters in comments, so parsing can treat the file as Latin-1, or even ASCII by ignoring any non-ASCII character.
- Lines are separated by CR (U+000D) or NL (U+000A) characters.
- Empty lines are ignored (so CR+NL can be used as line separator).
- Lines starting with a `#` character are comments, and are otherwise ignored.
- The remaining lines are key/value entries. They must contain a `:` character.
- The characters before the first `:` specify the package name and the characters after specify the package location.
- The package name must be a valid *package name* (see below) or be the empty string (the line which starts with `:`).
- If the same package name occurs twice in the file, it is an error. The tool may fail immediately when detecting the duplicate definition, or it may give a warning and continue running and not fail until the package name is actually used in an import (similarly to when the same name is imported from two different libraries).
- The value for a non-empty package name must be a valid URI reference.
- This value URI reference may have a fragment. If so, that fragment must be valid `x-www-form-urlencoded` key/value pairs with no repeated keys.
- The value for the empty package name must be a single package name. _(A valid package name is a valid URI path segment containing no `:` or `/`, so it is *also* a valid URI reference)_.

#### Package Names

A *package name* is a sequence of URI path characters ([RFC 3986] `pchar`) which are not a percent encoding (`%xx`) or colon (`:`, U+0058)&mdash;that is, the characters corresponding to `unreserved / sub-delims / '@'` in the RFC. A package name must further contain at least one non-`.` character. 

_Rationale: The name must be usable both as a directory name and a URI path segment, preferably without conversion. By using a subset of `pchar` without percent encodings, the name can be used directly in a URI. By disallowing `/`, `\` and `:` (where only colon is a `pchar` to begin with), as well as the names `.` and `..`, the name can be used as a directory name on most common file systems._

## Semantics

The `.packages` file defines a finite mapping from package names to package location URIs.

Each non-empty package name key in the file introduces that name as an *available package*. An available package's location URI is found by resolving the URI reference value of the package name's entry against the location of the `.packages` file _(so if the URI reference is relative, it is relative to the `.packages` file)_. This should denote a *directory*, so if the resulting URI's path does not end with a `/`, one is added at the end of the path. If the `.packages` file contains an entry with an empty name, the package name that is its value is considered the name of the *default package*. This mapping from package names to URIs, together with the default package, defines a *package resolution configuration*.

*Package URI resolution* uses a package resolution configuration to convert a package URI to a non-package URI, which is the *resolved location* of the package URI. 

A package URI of the form `package:packageName/packagePath` (optionally followed by query or fragment parts) is resolved by:

- If `packageName` is not an available package in the configuration, then the package URI cannot be resolved. This is most likely a compile-time error. The package URI has no resolved location.
- Otherwise find the package location URI of `packageName` in the configuration.
- Then create a URI reference with no scheme, no authority, a path of `./packagePath` and any query or fragment of the package URI.
- Resolve that URI reference with the package location URI as base URI. 
- The result of this is the *resolved location* of the package URI.

_The package URI may have a query and/or a fragment. If so, they will end up in the resolved location as well. It is almost never *desired* to have a query or fragment since a resulting `file:` URI has no use for such. If a base URI (like the package location URI) has a fragment or query part, it is always ignored when resolving a URI a non-empty path against it._

### Metadata

Metadata for an available package may be found in the fragments of the package location URIs of a `.packages` file. Tools which need access to this information can parse the fragment as  `x-www-form-urlencoded` key/value entries, and look up a value by key. A package location URI with no fragment has no metadata.

This way a package resolution configuration associates metadata with any package name, and thereby also with any package URI, by using the data associated with the package URI's package name.

Further, the configuration can associate metadata with a *non*-package URI. If the configuration contains an entry with an empty name, then its value must be a package name, and the package with this name is considered the "default package". The configuration associates the metadata of this package name with non-package URIs.

_The "default package" is intended for associating Pub package `.dart` files that are not in the `lib` directory with the Dart package being defined. This way metadata provided by the Pub package can be seen as applying to files in `test` or `bin` directories, even though those files cannot be accessed using a package URI._

The meaning of metadata is not specified here, just the general way to specify it. Individual language features will specify how they use metadata and how tools like Pub should add it to the `.packages` file.

## Tools

Dart tools which need to resolve package URIs (which includes any tool which understands imports in Dart files) needs access to a package resolution configuration. They get that by loading a `.packages` file.

### Finding the `.packages` File

Tools which need package resolution must support a `--packages` parameter which accepts a filename as argument (`--packages ../.packages` or `--packages=../.packages`).  This specifies the package resolution configuration file to load.

If a tool receives no "--packages" command line parameter, it should look for a way to resolve package URIs as follows:

1. Look for a `.packages` file next to the program entry point (which can then not be given using a package URI). For example running an application like:  
   `dart file:///home/somebody/dart/project/smarty/bin/main.dart`  
   will cause the tool to check for `file:///home/somebody/dart/project/smarty/bin/.packages`, and if that file exists, it load the file as its package resolution configuration file.
2. Otherwise the tool checks for the presence of a `.packages` file in the parent directory of the entry point, and recursively check each parent directory up to the root directory until a `.packages` file is found. That `.packages` file is used to resolve package URIs.
3. Otherwise, when no `.packages` file was found in the previous step, the tool must refuse to handle package URIs, as if no packages are available.

If a file is found, the package resolution configuration of the file is computed and used for resolving package URIs in the program. If a package URI cannot be resolved because its package name is not one of the available packages of the configuration, the program cannot be compiled.

_For example, the import `import 'package:test/test.dart';` is resolved by first case- and path-normalizing the URI (to avoid spurious `..` path segments and to get the package name into a canonical form), then splitting it into the package name, `test` and the remainder of the path, `test.dart`._

_If the `test` package was specified as:_

```
test:../../packages/test/lib#dart=2.4
```

_in the configuration file `file:///home/somebody/dart/project/smarty/.packages`, then the package location URI of the package `test` is `file:///home/somebody/dart/packages/test-1.6.0/lib/#dart=2.4`. The remaining path, `unittest.dart`, is resolved against this, getting `file:///home/somebody/dart/packages/unittest-0.9.9/lib/unittest.dart`._

### Support Package

There is a Dart package, [package_config] for reading and writing `.packages` files, converting to and from `Map<String, Uri>`. This can be used by all Dart based tools that need to read or write the package resolution configuration file.

### Creating `.packages` files.

The Pub tool writes a `.packages` file in a package's root directory when it has resolved and fetched a package's dependencies. It will also write some metadata as needed by current and future language features.

Other tools which want to create `.packages` files can use the [package_config] package to read, modify and write the files.

### Consuming `.packages` files.

Tools that need to support the "--packages" parameter includes the standalone VM, dart2js, the development compiler and the dart-analyzer.

The analyzer may analyze more than a single program, in which case it might recognize multiple package resolution configuration files that apply to separate subsets of files. How to do so is up to the analyzer.

## History

Version 2.0: Removed support for `packages` directories and added support for package metadata. Removed arguments for introducing the file to begin with.

Version 1.1: Changed format to allow some  non-identifiers as package names.

Version 1.0: Approved by DEP committee.

[package_config]: https://pub.dev/packages/package_config	"Package package_config on Pub"
[RFC 3986]: https://tools.ietf.org/html/rfc3986
[dart standard]: http://www.ecma-international.org/publications/standards/Ecma-408.htm
[specification document]: https://github.com/dart-archive/dart_enhancement_proposals/blob/master/Accepted/0005%20-%20Package%20Specification/DEP-pkgspec.md	"Package Resolution Configuration File v1.1"
